#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           leftTurn,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightTurn,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftPower,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightPower,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Custom map function
long map(long x, long in_min, long in_max, long out_min, long out_max) {
	return((x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min);
}
//TODO
//Turning
//4 wheels
task driveRightWheel() {
	float s;
	if(vexRT[Ch1] != 0) {
		s = vexRT[Ch2]/vexRT[Ch1];
	}
	float angle;//, turning;
	if(vexRT[Ch2] > 0) {
		angle = map((atan(s)*(2/PI)),-1,1,0,180);
		//turning = map(vexRT[Ch4],-127,127,-1,1);
	} else if(vexRT[Ch2] < 0) {
		angle = map((atan(s)*(2/PI)),-1,1,359,181);
		//turning = map(vexRT[Ch4],-127,127,-1,1);
	}
	float speed = sqrt((vexRT[Ch1]*vexRT[Ch1])+(vexRT[Ch2]*vexRT[Ch2]));
	//This has to be bigger than 32, no more than 127
	int turningSpeed = 50;
	//tolerance should be kept really low below 4
	int tolerance = 1;
	//Motor go zoom
	motor[rightPower] = speed;
	//What is the current angle (0-359)
	int offAngle = SensorValue[rightEncoder]%360;
	//Turn until it gets where it's supposed to be
	while(offAngle < angle + tolerance && offAngle > angle - tolerance) {
	//What is the current angle (0-359)
		offAngle = SensorValue[rightEncoder]%360;
		//Turn cc or ccc
		if(offAngle > 0) {
			motor[rightTurn] = turningSpeed;
		} else if(offAngle < 0) {
			motor[rightTurn] = -turningSpeed;
		}
	}
}

task driveLeftWheel() {
	float s;
	if(vexRT[Ch1] != 0) {
		s = vexRT[Ch2]/vexRT[Ch1];
	}
	float angle;//, turning;
	if(vexRT[Ch2] > 0) {
		angle = map((atan(s)*(2/PI)),-1,1,1,179);
		//turning = map(vexRT[Ch4],-127,127,-1,1);
	} else if(vexRT[Ch2] < 0) {
		angle = map((atan(s)*(2/PI)),-1,1,359,181);
		//turning = map(vexRT[Ch4],-127,127,-1,1);
	}
	float speed = sqrt((vexRT[Ch1]*vexRT[Ch1])+(vexRT[Ch2]*vexRT[Ch2]));
	//This has to be bigger than 32, no more than 127
	int turningSpeed = 50;
	//tolerance should be kept really low below 4
	int tolerance = 1;
	//Motor go zoom
	motor[leftPower] = speed;
	//What is the current angle (0-359)
	int offAngle = SensorValue[leftEncoder]%360;
	//Turn until it is close to where it's supposed to be
	while(offAngle < angle + tolerance && offAngle > angle - tolerance) {
	//What is the current angle (0-359)
		offAngle = SensorValue[leftEncoder]%360;
		//Turn cc or ccc
		if(offAngle > 0) {
			motor[leftTurn] = turningSpeed;
		} else if(offAngle < 0) {
			motor[leftTurn] = -turningSpeed;
		}
	}
}

//Notes
//Joystick gives values between -127 and 127 inclusive.

task main() {
	while(true) {
		startTask(driveRightWheel);
		startTask(driveLeftWheel);
	}
}
